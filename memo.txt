1. LoginForm : 아이디 비빌번호를 적고 LoginButton 클릭
2. const onSubmitForm 안에 dispatch(loginRequestAction({id,password}))실행된다
3. sagas 폴더의 user.js에서 watchLogin() 안의 "LOG_IN_REQUEST"가 실행되면서 
    Generator function* logIn() 이 실행된다.
4. 그와 동시에 reducer에서 "LOG_IN_REQUEST"가 실행되면서 isloggingIn 이 true가 되면서
   Spinner 가 돌아간다.
5. 1초후에 사가에 "LOG_IN_SUCCESS"가 실행된다. 그러면 Reducer에서도 LOG_IN_SUCCESS가 실행되고
    ...state,
    isLoggingIn: false, ==> 스피너가 없어지고
    isLoggedIn: true, ==> Login이 된상태가 되면서
    me: { ...action.data, nickname: "BuHoJang" } ==>로그인 정보인 me에 데이터가 들어간다.
    
    그러면 AppLayout에서 
    Col xs={24} md={6}>
          {isLoggedIn ? <UserProfile /> : <LoginForm />}
    </Col>    
    LoginForm 에서  UserProfile 로 바뀌게 된다. 
    
6. 사가에서는 서버랑통신해서 action.data에 서버데이터를 담아서 reducer에 넘긴다.
    
    function* logIn(action) {
  // Call은 데이터를 받아올때까지 기다리는 것이고 fork 는 데이터를 받아오면서 다른것도 동시에 실행된다.
  //   요청의 성공은 result.data , 실패는 err.response.data에 담겨져있따.

  try {
    // put은 thunk의 dispatch와 같다.
    // delay 는 setItemout과 기능이 같다.
    // const result = yield call(logInAPI)
    yield delay(1000);
    yield put({
      type: "LOG_IN_SUCCESS",
      data: action.data,
    });
  } catch (err) {
    yield put({
      type: "LOG_IN_FAILURE",
      data: err.response.data,
    });
  }
}

7. 그러면 리듀서에서 Redux를 통해 서버데이터를 중앙저장소에 장착한다. 

case "LOG_IN_SUCCESS":
      return {
        ...state,
        isLoggingIn: false,
        isLoggedIn: true,
        me: { ...action.data, nickname: "BuHoJang" },
      };


!!!!!!!!!!!PostForm Submit Data Flow

1.  PostForm에서 text를 입력후 submit를 누르면 dispatch(addPost(text))
    가 실행된다.
2.  Reducer에 addPost에서 데이터를 넘겨주면 
    
    Saga에서 function* watchAddPost() {
    yield takeLatest(ADD_POST_REQUEST, addPost);
    }

    Saga에서의 addPost가 실행된다.

    function* addPost(action) {
      try {
        // const result = yield call(addPostAPI,action.payload)
        yield delay(1000);
        yield put({
          type: ADD_POST_SUCCESS,
          data: action.data,
        });
      } catch (err) {
        yield put({
          type: ADD_POST_FAILURE,
          data: err.response.data,
        });
      }
    }

    서버의 응답에 따라 SUCCESS or FAILURE가 실행된다. 

3.  Saga의 post에서 data는 action.data에서 data로 다시 들어가게된다.

4.  Saga에서 ADD_POST_SUCCESS를 실행하면 Reducer에 ADD_POST_SUCCESS 
    가실행되고  dummyData에 action.data가 들어간다.
    addPostDone = true 가 되면서 input창의 content 가 초기화된다. 

!!!!!!!!!!!CommentForm Submit Data Flow
1.  pages/index.js(홈페이지) 에서 PostCard 에 props로 post를 보낸다.
2.  CommentForm에서 submit을 누르게 되면 data에 { content: commentText, postId: post.id, userId: id }
    들어가게 되고 ADD_COMMENT_REQUEST 가 실행된다.    
3.  postId는 props로 받고 userId는 useSelector에서 state.user.id로 가져오고
    content(댓글)는 입력된 commentText에서 가져온다.
4.  Saga에서 대기하고 있던 제너레이터가 ADD_COMMENT_REQUEST 를 감지하고
    addComment를 실행하게 된다. 
    
    function* addComment(action) {
      try {
        // const result = yield call(addPostAPI,action.payload)
        yield delay(1000);
        yield put({
          type: ADD_COMMENT_SUCCESS,
          data: action.data,
        });
      } catch (err) {
        yield put({
          type: ADD_COMMENT_FAILURE,
          data: err.response.data,
        });
      }
    }

    서버의 응답에 따라 SUCCESS or FAILURE가 실행된다.
5.  Reducer에서 ADD_COMMENT_SUCCESS 가 실행된다.
    
    case ADD_COMMENT_SUCCESS: {
      // acton.data.content , action.postId, action.userId가 넘어온다.
      // 댓글을 찾을려면 mainPosts 안에 Comment로 접근하고 불변성을 지키면서 추가해야한다.
      
      1) id가 같은 post의 아이디를 postIndex에 저장한다. 
      const postIndex = state.mainPosts.findIndex(
        (v) => v.id === action.data.postId
      );

      2) mainPosts에서 postIndex를 가진 post를 새로운 객체 post에 저장한다.
      const post = { ...state.mainPosts[postIndex] };

      3) post 의 Comment에 접근해서 comment를 추가한다.
      post.Comments = [dummyComment(action.data.content), ...post.Comments];

      4) mainPosts를 새롭게 만든다. 
      const mainPosts = [state.mainPosts];
      mainPosts[postIndex] = post;

      return {
        ...state,
        addCommentLoading: false,
        addCommentDone: true,
      };
    }

!!! Post Comment 추가 삭제!
1. 사용자가 게시글을 작성한다. 그러면 Post Reducer에서 ADD_POST_SUCCESS 를 실행하게 된다. 게시글이 작성되면  User Reducer에서있는

    const dummyUser = (data) => ({
      ...
      Posts: [{ id: 1 }], <---------------------------- 이부분에 포스트가 추가되어야한다.
      ...
    });

    User 파트는 User Reducer에서 작동해야하는데 이걸 어떻게 처리할 것인가?? 게시글은 PostReducer 나에대한 정보는 UserReducer 이걸
    어떻게 할 것인가??
    Post를 1개 삭제하면 dummyUser.Posts 에서도 id가 1개 빠져야한다. 

    1)  User상태를 바꾸기 위해서는 Action을 만든다.
        export const ADD_POST_TO_ME = 'ADD_POST_TO_ME';
        export const REMOVE_POST_OF_ME = 'REMOVE_POST_OF_ME';
    2)  PostSaga에서 UserAction을 실행할 수 있다.   



!!! LoadPost Data Flow
1. UseEffect를 통해 홈화면 로딩시 LOAD_POST_REQUEST 를 호출한다.
const Home = () => {
    const dispatch = useDispatch();

    useEffect(() => {
      dispatch({
        type: LOAD_POST_REQUEST,
      });
    }, []);

2. 사가에서 fork(watchLoadPosts) 통해 인식하고 function loadPosts를 실행한다.
    function* watchLoadPosts() {
      yield takeLatest(LOAD_POST_REQUEST, loadPosts);
    }

3. loadPosts action에서 LOAD_POST_SUCCESS 실행하고 더미데이터 10개를 만들어 Reducer로 넘긴다.
    function* loadPosts(action) {
      try {
        // const result = yield call(addCommentAPI, action.data);
        yield delay(1000);
        yield put({
          type: LOAD_POST_SUCCESS,
          data: generateDummyPost(10),
        });
      } catch (err) {
        yield put({
          type: LOAD_POST_FAILURE,
          data: err.response.data,
        });
      }
    }

4. Saga에서 넘긴 10개 데이터를 concat을 통해 기존 데이터와 합쳐준다.
      case LOAD_POST_SUCCESS:
          draft.loadPostLoading = false;
          draft.loadPostDone = true;
          // action.data에 추가되는 더미데이터가 있고 그것을 기존데이터에 합쳐준다.
          draft.mainPosts.action.data.concat(draft.mainPosts);
          draft.hasMorePosts = draft.mainPosts.length < 50;
          break;


!!! Following Button Data Flow
1. 팔로우 버튼을 누르면 버튼이 언팔로우로 바뀌어야한다.
2. User Card의 팔료잉 숫자가 +1 이 되어야한다. 
3. 언팔로우를 누르면 버튼 네임이 팔로우로 바뀌고
4. User Card에 팔로잉 숫자가 -1 이 되어야한다. 
